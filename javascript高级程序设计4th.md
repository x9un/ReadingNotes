
---

[TOC]

---

# javascript高级程序设计4th

## chapter 1
JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。  
ECMAScript：由ECMA-262定义并提供核心功能。  
文档对象模型（DOM）：提供与网页内容交互的方法和接口。  
浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。  

## chapter 2
+ 浏览器解析行内脚本的方式决定了它在看到字符串`</script>`时，会将其当成结束的`</script>`标签。想避免这个问题，只需要转义字符“\”①即可  
+ 与解释行内JavaScript一样，在解释外部JavaScript文件时，页面也会阻塞  
+ 不过，引用了放在别人服务器上的JavaScript文件时要格外小心，因为恶意的程序员随时可能替换这个文件。在包含外部域的JavaScript文件时，要确保该域是自己所有的，或者该域是一个可信的来源。`<script>`标签的integrity属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持
+ XHTML 是将 HTML 作为 XML 的应用重新包装的结果
+ `<noscript>`

## chapter 3
1. 变量
+ var声明提升
+ let声明的范围是块作用域，而var声明的范围是函数作用域
+ let也不允许同一个块作用域中出现冗余声明
+ let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升
+ 在let声明之前的执行瞬间被称为“暂时性死区”
+ 与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）
+ let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续，所以要避免重复声明
+ const 与 let 基本相同
+ 实践:不使用 var ; const 优先 let 其次

2. 数据类型
+ 类型:Undefined、Null、Object、Boolean、Number、String和Symbol(符号)
+ 未定义的变量会报错，未赋值的变量的值才是 undefined
+ 无论是声明还是未声明，typeof返回的都是字符串"undefined"
+ null值表示一个空对象指针
+ 在小数点后面没有数字的情况下，数值就会变成整数
+ NaN:表示本来要返回数值的操作失败了（而不是抛出错误）
+ 0、+0或-0相除会返回NaN;如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity
+ NaN不等于包括NaN在内的任何值
+ Number()、parseInt()和parseFloat()
+ 字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示
+ ECMAScript中的字符串是不可变的
+ 模板字面量标签函数
+ 符号的用途是确保对象属性使用唯一标识符
+ 使用全局符号注册表

3. 操作符
+ 将一元加应用到非数值，则会执行与使用Number()转型函数一样的类型转换
+ ECMAScript 7新增了指数操作符，Math.pow()现在有了自己的操作符**

4. 语句
+ 标签语句:嵌套循环

5. 函数
+ 不指定返回值的函数实际上会返回特殊值undefined。

# chapter 4 变量、作用域与内存
1. 原始值与引用值
+ JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间
+ 在操作对象时，实际上操作的是对该对象的引用
+ 原始值不能有属性
+ 原始类型的初始化可以只使用原始字面量形式
+ 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，互相独立
+ 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。
+ typeof 判断原始值;instance of 判断引用值

2. 执行上下文和作用域
+ 在浏览器中，全局上下文就是我们常说的window对象；通过var定义的全局变量和函数都会成为window对象的属性和方法
+ 全局上下文在应用程序退出前才会被销毁
+ 上下文栈
+ 作用域链 决定了各级上下文中的代码在访问变量和函数时的顺序:代码正在执行的上下文的变量对象始终位于作用域链的最前端
+ 活动对象
+ 代码执行时的标识符解析
+ `try/catch语句的catch块` `with语句` 这两种情况下，都会在作用域链前端添加一个变量对象
+ 在使用var声明变量时，变量会被自动添加到最接近的上下文
+ let const 块级，块级由`{}`定义
+ let在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用let变量
+ 尽可能地多使用const声明

3. 垃圾回收
+ 标记策略：标记清理和引用计数
+ 最常用的垃圾回收策略是标记清理
+ 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了。然后内存清理
+ `引用计数` 
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）  

+ 声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.垃圾回收程序下次运行的时候就会释放引用数为0的值的内存
+ 引用计数严重的问题：循环引用 - 在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接，把变量设置为null实际上会切断变量与其之前引用值之间的关系。IE9 改了
+ 垃圾回收程序会周期性运行
+ 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除
+ IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值
+ 那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性
+ 解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收  
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助  
+ 通过const和let声明提升性能
+ 隐藏类和删除操作:使用delete关键字会导致生成相同的隐藏类片段,最好设置成 null
+ 内存泄漏:使用JavaScript闭包很容易在不知不觉间造成内存泄漏
+ 静态分配与对象池:  (极端优化，一般不考虑)
浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度  
在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象  
由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行  
如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存  
可以用数组实现，但是要避免数组的动态操作，比如删除添加，事先想好这个数组有多大
