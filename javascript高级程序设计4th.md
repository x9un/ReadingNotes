
---

[TOC]

---

# javascript高级程序设计4th

## chapter 1
JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。  
ECMAScript：由ECMA-262定义并提供核心功能。  
文档对象模型（DOM）：提供与网页内容交互的方法和接口。  
浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。  

## chapter 2
+ 浏览器解析行内脚本的方式决定了它在看到字符串`</script>`时，会将其当成结束的`</script>`标签。想避免这个问题，只需要转义字符“\”①即可  
+ 与解释行内JavaScript一样，在解释外部JavaScript文件时，页面也会阻塞  
+ 不过，引用了放在别人服务器上的JavaScript文件时要格外小心，因为恶意的程序员随时可能替换这个文件。在包含外部域的JavaScript文件时，要确保该域是自己所有的，或者该域是一个可信的来源。`<script>`标签的integrity属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持
+ XHTML 是将 HTML 作为 XML 的应用重新包装的结果
+ `<noscript>`

## chapter 3
1. 变量
+ var声明提升
+ let声明的范围是块作用域，而var声明的范围是函数作用域
+ let也不允许同一个块作用域中出现冗余声明
+ let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升
+ 在let声明之前的执行瞬间被称为“暂时性死区”
+ 与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）
+ let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续，所以要避免重复声明
+ const 与 let 基本相同
+ 实践:不使用 var ; const 优先 let 其次

2. 数据类型
+ 类型:Undefined、Null、Object、Boolean、Number、String和Symbol(符号)
+ 未定义的变量会报错，未赋值的变量的值才是 undefined
+ 无论是声明还是未声明，typeof返回的都是字符串"undefined"
+ null值表示一个空对象指针
+ 在小数点后面没有数字的情况下，数值就会变成整数
+ NaN:表示本来要返回数值的操作失败了（而不是抛出错误）
+ 0、+0或-0相除会返回NaN;如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity
+ NaN不等于包括NaN在内的任何值
+ Number()、parseInt()和parseFloat()
+ 字符串可以使用双引号（"）、单引号（'）或反引号（\`）标示
+ ECMAScript中的字符串是不可变的
+ 模板字面量标签函数
+ 符号的用途是确保对象属性使用唯一标识符
+ 使用全局符号注册表

3. 操作符
+ 将一元加应用到非数值，则会执行与使用Number()转型函数一样的类型转换
+ ECMAScript 7新增了指数操作符，Math.pow()现在有了自己的操作符**

4. 语句
+ 标签语句:嵌套循环

5. 函数
+ 不指定返回值的函数实际上会返回特殊值undefined。

# chapter 4 变量、作用域与内存
1. 原始值与引用值
+ JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间
+ 在操作对象时，实际上操作的是对该对象的引用
+ 原始值不能有属性
+ 原始类型的初始化可以只使用原始字面量形式
+ 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，互相独立
+ 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。
+ typeof 判断原始值;instance of 判断引用值

2. 执行上下文和作用域
+ 在浏览器中，全局上下文就是我们常说的window对象；通过var定义的全局变量和函数都会成为window对象的属性和方法
+ 全局上下文在应用程序退出前才会被销毁
+ 上下文栈
+ 作用域链 决定了各级上下文中的代码在访问变量和函数时的顺序:代码正在执行的上下文的变量对象始终位于作用域链的最前端
+ 活动对象
+ 代码执行时的标识符解析
+ `try/catch语句的catch块` `with语句` 这两种情况下，都会在作用域链前端添加一个变量对象
+ 在使用var声明变量时，变量会被自动添加到最接近的上下文
+ let const 块级，块级由`{}`定义
+ let在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用let变量
+ 尽可能地多使用const声明

3. 垃圾回收
+ 标记策略：标记清理和引用计数
+ 最常用的垃圾回收策略是标记清理
+ 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了。然后内存清理
+ `引用计数` 
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）  

+ 声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1.垃圾回收程序下次运行的时候就会释放引用数为0的值的内存
+ 引用计数严重的问题：循环引用 - 在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接，把变量设置为null实际上会切断变量与其之前引用值之间的关系。IE9 改了
+ 垃圾回收程序会周期性运行
+ 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除
+ IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值
+ 那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性
+ 解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收  
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助  
+ 通过const和let声明提升性能
+ 隐藏类和删除操作:使用delete关键字会导致生成相同的隐藏类片段,最好设置成 null
+ 内存泄漏:使用JavaScript闭包很容易在不知不觉间造成内存泄漏
+ 静态分配与对象池:  (极端优化，一般不考虑)
浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度  
在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象  
由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行  
如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存  
可以用数组实现，但是要避免数组的动态操作，比如删除添加，事先想好这个数组有多大

## chapter 5 基本引用类型
1. Date()
+ 在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示
+ Date.parse() Date.now() Date.UTC()
+ 与Date.parse()一样，Date.UTC()也会被Date构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是GMT日期
+ toLocaleString()和toString()可能只对调试有用，不能用于显示
+ Date类型的valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示

2. RegExp
+ 
g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。  
i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。  
m：多行模式，表示查找到一行文本末尾时会继续查找。  
y：粘附模式，表示只查找从lastIndex开始及之后的字符串。  
u：Unicode模式，启用Unicode匹配。  
s：dotAll模式，表示元字符.匹配任何字符（包括\n或\r）
+ 元字符转义
```
( [ { \ ^ $ | ) ] } ? * + . 
```
+ 字面量创建 || RegExp 构造函数创建
+ RegExp实例的主要方法是exec()，主要用于配合捕获组使用
返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index是字符串中匹配模式的起始位置，input是要查找的字符串  
全局模式  
粘附标记y，则每次调用exec()就只会在lastIndex的位置上寻找匹配项。粘附标记覆盖全局标记  
+ 正则表达式的另一个方法是test()
+ 无论正则表达式是怎么创建的，继承的方法toLocaleString()和toString()都返回正则表达式的字面量表示
+ 正则表达式的valueOf()方法返回正则表达式本身。
+ RegExp() 本身的属性有全名和简写
+ 简写形式，使用中括号语法来访问
+ RegExp还有其他几个构造函数属性，可以存储最多9个捕获组的匹配项。这些属性通过RegExp. $1~RegExp.$9来访问，分别包含第1~9个捕获组的匹配项
+ RegExp构造函数的所有属性都没有任何Web标准出处，因此不要在生产环境中使用它们

3. 原始值包装类型
+ 原始值本身不是对象，因此逻辑上不应该有方法
+ 已读模式访问字符串
(1) 创建一个String类型的实例  
(2) 调用实例上的特定方法  
(3) 销毁实例  
+ 引用类型与原始值包装类型的主要区别在于对象的生命周期
通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间  
+ 不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的
+ 所有对象在布尔表达式中都会自动转换为true
+
```js
console.log(typeof falseObject);             // object console.log(typeof falseValue);              // boolean console.log(falseObject instanceof Boolean); // true console.log(falseValue instanceof Boolean);  // false
```
+ 不要使用 boolean 对象
+ 多个浮点数值的数学计算不一定得到精确的结果
+ number: toFixed() toExponential() ES6:Number.isInteger() Number.isSafeInteger()
+ 不建议直接实例化Number对象,与 boolean 类似
+ string: .length() .charAt() .charCodeAt() .fromCharCode()
+ 16位只能唯一表示65 536个字符。这对于大多数语言字符集是足够了，在Unicode中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode采用了一个策略，即每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对  
+ normalize()方法
+ 字符串方法:`concat()` `+` `slice()` `substr()` `substring()` `indexOf()` `lastIndexOf()` `startsWith()` `endsWith()` `includes()` `repeat()` `padStart()` `padEnd()` 
+ 字符串的原型上暴露了一个@@iterator方法，表示可以迭代字符串的每个字符

4. 单例内置对象
+ Global:代码不会显式访问,在全局作用域中定义的变量和函数都会变成Global对象的属性  
+ URL编码方法，eval()方法
+ 浏览器将window对象实现为Global对象的代理，所有全局作用域中声明的变量和函数都变成了window的属性

5. 
+ 函数实际上是Function类型的实例，也就是说函数也是对象
+ 当代码开始执行时，全局上下文中会存在两个内置对象：Global和Math

## chapter 6 集合引用类型
1. object
+ 如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，也可以使用中括号语法

2. array
+ 数组中每个槽位可以存储任意类型的数据
+ ES6：from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实
+ 数组空位: [,,]以前用,来占空位，ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异,这个要少用
+ 通过修改length属性，可以从数组末尾删除或添加元素，undefined 填充
+ 检测数组:
使用instanceof的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下  
解决: Array.isArray()
+ 迭代器:
ES6: keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而entries()返回索引/值对的迭代器
+ 复制和填充:
ES6:批量复制方法copyWithin()，以及填充数组方法fill()
+ 转换:
如果数组中某一项是null或undefined，则在join()、toLocaleString()、toString()和valueOf()返回的结果中会以空字符串表示  
+ 栈方法:
push() pop()
+ 队列:
shift() unshift()
+ 排序:reverse() sort()
+ 操作方法:concat() slice() splice()

3. 定型数组
+ 目的是提升向原生库传输数据的效率
+ ArrayBuffer DataView
+ 定型数组是另一种形式的ArrayBuffer视图

4. Map
+ 与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序

5. WeakMap
+ 这些键不属于正式的引用，不会阻止垃圾回收
+ 因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力
+ 使用弱映射

6. Set
+ Set会维护值插入时的顺序，因此支持按顺序迭代

7. WeakSet

## chapter 7 迭代器与生成器
1. 迭代器模式
+ 实现Iterable接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator接口的对象的能力
+ 可选的return()方法用于指定在迭代器提前关闭时执行的逻辑
+ 要知道某个迭代器是否可关闭，可以测试这个迭代器实例的return属性是不是函数对象
+ 任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器

2. 生成器
+ 生成器的形式是一个函数，函数名称前面加一个星号（\*）表示它是一个生成器
+ 箭头函数不能用来定义生成器函数。
+ 生成器对象一开始处于暂停执行（suspended）的状态
+ yield关键字可以让生成器停止和开始执行
+ 停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行
+ 可以使用星号增强yield的行为，让它能够迭代一个可迭代对象，从而一次产出一个值
+ yield\*最有用的地方是实现递归操作，此时生成器可以产生自身
+ return()方法会强制生成器进入关闭状态。提供给return()方法的值，就是终止迭代器对象的值
+ throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中

## chapter 8 对象、类与面向对象编程
1. 理解对象
+ 要修改属性的默认特性，就必须使用Object.defineProperty()方法
+ 一个属性被定义为不可配置之后，就不能再变回可配置的了
+ 数据属性
+ 访问器属性
+ `year_`中的下划线常用来表示该属性并不希望在对象方法的外部被访问
+ 访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生
+ Object.define-Properties()方法 定义多个属性
+ Object.getOwnPropertyDescriptor() 读取属性的特性
+ Object.assign() 合并对象 Object.assign()实际上对每个源对象执行的是浅复制，浅复制意味着只会复制对象的引用
+ 对象标识及相等判定 Object.is()
+ 增强的对象语法: 
属性值简写  
可计算属性  
简写方法名  
+ 对象解构
在对象解构的上下文中，原始值会被当成对象  
null和undefined不能被解构，否则会抛出错误  
嵌套解构  
部分解构  
参数上下文匹配  

2. 创建对象
+ 工厂模式:用于抽象创建特定对象的过程。工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题
+ 构造函数模式:按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头,定义自定义构造函数可以确保实例被标识为特定类型  
构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍  
+ 原型模式
