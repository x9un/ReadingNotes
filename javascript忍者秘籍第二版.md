
---

[TOC]

---

# javascript忍者秘籍第二版note

## chapter 2 - 运行时的页面构建过程

### questions
1. 浏览器是否总是会根据给定的 HTML 来渲染页面
2. web 应用一次能处理多少个事件
3. 为什么浏览器使用事件队列来处理事件

### notes
1. 生命周期概述
+ 客户端 web 从指定某个网址开始，由页面构建和事件处理组成
+ 输入 url - 发生请求并发送至服务器 - 执行某些动作或获取某些资源，响应发送回客户端 - 处理 html/css/js 并构建结果页面 - 监控事件队列，一次处理其中的一个事件 - 与页面元素交互  - 关闭 web 界面 - 生命周期结束
+ 页面构建:创建用户界面
+ 事件处理:进入循环等待事件的发生，发生后调用事件处理器

2. 页面构建阶段
+ 步骤: 解析 HTML 并构建文档对象模型(DOM) ; 执行 js
+ 两个步骤会交替执行
+ 浏览器遇到脚本节点时会停止 HTML 到 DOM 的执行

3. 事件处理
+ 浏览器执行环境的核心思想:单线程执行模型
+ 放置事件的队列在页面构建阶段和事件处理阶段外
+ 事件是异步的
+ 按事件生成顺序处理

4. 注册事件处理器
+ 函数赋值给某个特殊属性||内置 addEventListener 方法
+ 第一种不推荐:对于某个事件只能注册一个事件处理器

## chapter 6 - 未来的函数:生成器与 promise
generator是特殊类型的函数
promise对象是一个占位符，暂时替代那些尚未计算出但未来会计算出的值

### questions
1. generator 函数的主要用途是什么?

2. 在异步代码中,为什么使用 promise 比使用简单的回调函数更好?

3. 使用 Promise.race 来执行很多长期执行的任务时，promise 最终会在什么时候变成 resolved 状态? 它什么时候会无法变成 resolved 状态?

### notes
1. 原因: 从服务器获取数据是一个长时间操作，js依赖单线程执行模型，所以UI渲染会暂停，应用会无响应。

2. generator
```js
function* WeaponGenerator(){//在关键字function后添加星号*定义生成器函数
	...
	yield "Katana";//在生成器函数内使用yield生成独立的值
	...
}
```

3. 调用生成器不会执行生成器函数，而是创建一个迭代器(iterator)对象与生成器通信

4. 通过迭代器对象控制生成器:
+ 迭代器用于控制生成器的生成。
+ 最基本接口:next 方法，用来向生成器请求一个值。
+ 流程: 生成一个当前值后，生成器就会非阻塞地挂起执行，等待下一次值请求,返回一个对象。属性value为设定值，属性done为false。当没有代码可以执行使，value-undefined done-true

5. 使用生成器
+ 可以无限循环，因为只有请求.next才会迭代下一次的循环
+ 场景:为每个对象赋唯一id值
+ 一般与 for-of 配套
```js
//用生成器遍历DOM树
function* DomTraversal(element){
	yield element;
	element=element.firstElementChild;
	while(element){
		yield* DomTraversal(element); //用 yield* 将迭代控制转移到另一个生成器实例上
		element=element.nextElementSibling;
	}
}

const subTree=document.getElementById("subTree");
for(let element of DomTraversal(subTree)){   //使用 for-of 对节点进行循环迭代
	assert(element!==null,element.nodeName);
}
```

6. 与生成器交互
+ 作为生成器函数参数发送值 & 使用 next 方法向生成器发送值
+ next 的参数传入需要有一个挂起的生成器

7. 探索生成器内部构成
+ 过程:挂起开始 - 执行 - 挂起让渡 - 完成
+ 生成器的执行环境上下文会暂时挂起来并在将来恢复，因为迭代器保持着对其的引用，所以即使 generator 的执行环境从上下文中弹出也不会被销毁

8. 使用promise
+ 处理异步
+ 在promise对象上使用 then 方法，可以传入两个回调函数，调用 resolve 就会调用第一个，而调用 reject 时会调用第二个

9. 简单理解回调函数所带来的问题
+ 回调函数发生错误时无法用内置构造函数处理，错误难以处理
原因: 调用回调函数的代码一般不会和开始任务的这段代码位于事件循环的同意步骤，错误会丢失
+ 执行连续步骤很棘手
+ 执行很多并行任务也棘手

10. 深入研究 promise
+ 一开始是等待状态，然后根据resolve和reject分化为fulfilled和rejected状态
+ then 方法用于建立一个预计在promise被成功实现后执行的回调函数

11. 拒绝 promise
+ 显示拒绝：在一个 promise 的执行函数中调用传入的 reject 方法
+ 隐式拒绝：正处理的一个 promise 的过程中抛出了一个异常，此时会自定位到拒绝回调函数中

12. 把生成器和 promise 相结合
+ 异步任务放入一个生成器中，执行生成器函数，将执行权让渡给生成器，防止阻塞。承诺兑现时通过迭代器的next执行生成器

13. 面向未来的 async 函数
+ async & await

## chapter 7 - 面向对象与原型
+ 探讨原型
+ 使用函数作为构造器
+ 使用原型扩展对象
+ 避免常见的问题
+ 使用继承创建类

### Question
+ 如何知道一个对象是否可以访问特定的属性
+ 在 Javascript 中使用对象时，为什么原型链至关重要
+ ES6 中的关键字 class 是否改变了 Javascript 中对象的工作机制

### notes
1. 理解原型
+ 查找属性时，若对象本身不具有该属性，则会查找原型上是否有该属性
+ 操作符 in 测试对象是否具有某一个特点的属性
+ 对象的原型属性是内置属性，无法直接访问
+ Object.setPrototypeOf(yoshi,hattori),将yoshi的原型设置为hattori

2. 对象构造器与原型
+ 每个函数都有一个原型对象;每个函数的原型都有一个constructor属性，该属性指向函数本身;constructor对象的原型设置为新创建的对象的原型
+ 使用构造 new 时，新构造的对象设置为构造函数的原型的引用

3. 实例属性
+ 在实例中可以查找到的属性，将不会查找原型

4. Javascript 动态特性的副作用
+ 替换构造器原型后，新创建的实例所引用的是替换后的原型

5. 通过构造函数实现对象类型
+ 使用 constructor 属性，我们可以访问创建该对象时所用的函数。这个特性可以用于类型校验
+ 操作符 instanceof 提供了一种用于检测一个实例是否由特定构造函数创建的方法
+ 使用 constructor 的引用创建新对象
```js
function Ninjia(){}

const ninja = new Ninja();
const ninja2 = new ninjia.constructor();
//ninjia 和 ninjia2 是对同一原型的两个不同实例
```

6. 实现继承
```js
Ninja.prototype = new Person();
//实现 Ninja 继承 Person
```
+ 通过 instanceof 可以判定函数是否继承原型链上的对象功能

7. 重写 constructor 属性的问题
+ 设置 Person 实例对象作为 Ninja 构造器的原型时，我们丢失了 Ninja 与 Ninja初始原型之间的关联
+ 调整属性的配置信息，可以使用内置的 Object.defineProperty

8. instanceof 操作符
+ 真正语义：检查右边的函数原型是否存在于操作符左边的对象的原型链上

9. 在 ES6 使用 Javascript 的 class
+ class 是一个语法糖，用于继承，底层是基于原型的实现
+ 静态方法:实例不能访问，类可以访问

10. 实现继承
(ES6)
+ `extends` 实现继承
+ `super` 调用基类构造函数

## chapter 8 - 控制对象的访问
### Question
1. 通过 getter 和 setter 访问属性值有什么好处
2. 代理与 getter 和 setter 的主要区别是什么
3. 代理对象的常见问题是什么？列举3项代理对象的常见问题

### notes
1. 使用 getter 和 setter 控制属性访问
2. 定义 getter 和 setter
+ 通过对象字面量/ES6中的class
+ 使用内置 Object.defineProperty 方法定义
+ 属性名前添加关键字 get/set
+ 获取属性值隐式调用 get，对属性赋值隐式调用 set
+ getter 可以定义计算属性 setter 可用于实现数据验证与日志记录
3. 使用代理控制访问
+ 控制对象的全部交互类型
+ 定义当对象发生交互时可执行的自定义行为，如 读取/设置属性值，或调用方法
+ setter/getter 仅能控制单个对象属性，代理可用于对象交互的通用处理
+ 代理更易于在对象上添加日志

4. 使用代理检测性能
5. 使用代理自动填充属性
6. 使用代理实现负数组索引
7. 代理的性能消耗

## chapter 9 - 处理集合
### Question
1. 使用对象作为字典或 Map 的常见缺陷有哪些?
2. 在 Map 中，键值对可以是哪些类型?
3. Set 中的成员必须是相同类型吗?

### notes
+ 使用 Map 可以创建字典类型，建立键值对的映射关系
+ Set 集合中的成员都是唯一的,不允许出现重复的成员

1. 创建数组
+ 使用内置 Array 构造函数
+ 使用数组字面量 [] 
+ 优先使用数组字面量:
[] 2个字符,由于 js 的高度动态特性,无法阻止修改内置的 Array 构造函数，意味着 new Array() 创建的不一定是数组
+ 数组是对象

2. 在数组两端添加，删除元素
+ push: 末尾
+ unshift: 开头添加
+ pop: 末尾
+ shift: 开头删除
+ pop/push 因为对末尾进行操作，速度会比 shift/unshift 快很多，非特殊情况不使用后者

3. 在数组任意位置添加，删除元素
+ delete: 只是创建空元素
+ splice()

4. 数组常用操作
+ 遍历数组：
```js
ninjas.forEach(ninja=>{
	assert(ninja !== null,ninja);
})
```
+ 基于现有的数组元素映射创建新数组
```js
ninjas.map(ninja=>ninja.weapon);
```
+ 验证数组元素是否匹配指定的条件
```js
ninjas.every(ninja => "name" in ninja);//所有
ninjas.some(ninja => "weapon" in ninja);//至少一个
```
+ 查找特定数组元素
find(ES6):返回满足条件的第一个元素
filter: 返回多个、
indexOf()
lastIndexOf()
findIndex()
+ 聚合数组，基于数组元素计算
.sort()
.reduce()

5. 复用内置的数组函数
模拟类数组方法
```js
function(elem){
	Array.prototype.push.call(this,elem);
}
```
通常 Array.prototype.push 方法通过自身函数上下文执行数组。通过 call() 将上下文改为我们定义的对象

6. 别把对象当作 Map
+ 原型继承属性(存在访问原型属性的风险)以及 Key 仅支持字符串，所以通常不能使用对象作为 map
+ 处理 Map 的一个基本概念是确定两个映射的 key 是否相等
+ forof 循环遍历 Map

7. Set
+ 成员值唯一
+ 并集
```js
new Set([...ninjas],[...samurai]);
```
+ 交集
```js
new Set(
	[...ninjas].filter(ninja => samurai.has(ninja))
	);
```
+ 差集
```js
new Set(
	[...ninjas].filter(ninja => !samurai.has(ninja))//只保留存在于 ninjas 中但不存在与 samurai 中的元素
	);
```

## chapter 10 - 正则表达式

### quesiton
1. 何时优先使用正则字面量，而不使用正则对象？
2. 什么是粘连匹配，如何开启粘连匹配？
3. 使用全局和非全局正则表达式的区别是什么？

### notes
+ 正则表达式通过斜线进行分隔
+ 优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，使用构造函数的方式
+
i:大小写不敏感
g:查找所有匹配项
m:允许多行匹配
y:开启粘连匹配
u:允许使用 Unicode 点转义符

1. 术语和操作符
+ 精确匹配 `//`
+ 匹配字符集 `[abc]` `[^abc]` `[a-c]`
+ 转义 反斜线`\`
+ 起止： 起`/^abc/`  止`/abc$/`
+ 重复出现：
指定字符出现0次/1次 `/t?est/`   
指定字符出现1次/多次 `/t+est/`   
指定字符出现0次/1次/多次 `/t*est/`  
指定重复次数 `/a{4}/` 出现4次  
指定循环次数的范围 `/a{4,10}/` 匹配(4,10)个  
指定开放区间 `/a{4,}/` 匹配4个或更多个连续的字符  

2. 预定义字符集

3. 分组: `()`

4. 或操作符 `|`

5. 反向引用:使用反斜线加上数组表示引用

6. 编译正则表达式
+ 通过预定义正则表达式提升性能
+ 每个正则表达式都有一个独特的对象表示

7. 执行简单捕获
+ 正则中使用圆括号定义捕获

8. 使用全局表达式进行匹配
+ g 标识符
+ 返回全部匹配结果但不会返回捕获结果
+ 使用 exec 方法进行捕获与全局搜索
+ exec 保留前一次调用的结果，每次调用返回的都是下一次的匹配及捕获结果

9. 捕获的引用
+ 自身匹配/替换字符串

10. 未捕获的分组
+ 被动子表达式 `?:` 只有外层圆括号会创建捕获，内层圆括号变成一个被动子表达式

11. 使用正则表达式解决常见的问题
+ 匹配换行: `/[\S\s]*/`
+ 匹配 Unicode 字符: `/[\w\u0080-\uFFFF_-]+/`
+ 匹配转义字符: `/^((\w+)|(\\.))+$/`

## chapter 11 代码模块化
### question
+ 在 JS ES6 之前，可以使用什么现有机制近似实现模块化
+ AMD 和 CommonJS 模块化规范有什么区别
+ 使用 ES6 时，需要使用哪两条语句来使 tryThisOut() 函数同时调用一个模块中的 test 和另一个模块中的 guineaPig

### notes
1. 在 JavaScript ES6 之前的版本中模块化代码
+ 每个模块系统至少应该能够执行以下操作
定义模块接口  
隐藏模块的内部实现  

2. 使用对象、闭包和立即执行函数实现模块
+ 隐藏模块的内部实现:使用函数作为模块，立即执行函数
+ 定义模块接口:利用对象和闭包  
函数模块返回代表模块公共接口的对象，闭包保持模块内部变量  
+ 模块模式缺点: 
通过模块扩展无法共享模块的私有变量  
需要考虑正确的依赖顺序  

3. 使用 AMD 和 CommonJS 模块化 JavaScript 应用
+ AMD 设计理念基于浏览器，CommonJS 是面向通用 JavaSCript 环境
+ AMD：
define() 
优点: 
自动处理依赖，无需考虑模块引入的顺序  
异步加载模块，避免阻塞  
在同一个文件中可以定义多个模块  
+ CommonJS 使用基于文件的模块，module.exports 作为模块的公共接口
+ CommonJS 文件同步加载。服务端模块加载相对更快，客户端需要远程下载，同步加载意味着阻塞  
优势:  
语法简单: 只需定义 module.exports 属性，引用模块只需 require  
是 Node.js 默认的模块格式，可以使用npm  
缺点: 不显式支持浏览器。浏览器端的 JS 不支持 module 变量和 export 属性

4. ES6 模块
+ 结合了 CommonJS 和 AMD 的优点:  
语法相对简单，并且基于文件  
支持异步模块加载  
+ ES6 模块的主要思想是必须显式地用标识符导出模块,才能从外部访问模块
+ export - 从模块外部指定标识符
+ import - 导入模块标识符

5. 导出和导入功能
```js
export {message,sayHiToNinja};//导出
import {message,sayHiToNinja} from "Ninja.js";//导入
import * as ninjaModule from "Ninja.js";//* 匹配所有标识符 as 后接模块别名 *必须跟as
```
+ 默认导出
```js
export default
import ImportedNinja from "Ninja.js";//可以任意指定名称
```
+ 重命名
```js
export { sayHi as sayHello }//import 同理
```

## chapter 12 DOM 操作
### questions
+ 为什么在注入 HTML 之前需要在预解析页面中可以自动闭合的元素
+ 使用 DOM 片段插入 HTML 的好处是什么
+ 如何确定页面上隐藏元素的尺寸

### notes
1. 预处理 HTML 源字符串
+ 选项元素不能孤立存在
+ HTML 中只支持一小部分的自闭合元素，在某些浏览器下可能会导致异常
+ 将  `<table />` 转换为 `<tabel></table>`

2. 包装 HTML
+ 通过 innerHTML 将该字符串直接注入到
+ HTML 字符串可以在使用对应父元素包装后，直接注入到任意容器元素中
第二种更推荐，因为只需很少的浏览器兼容代码	

3. DOM 的特性和属性
+ e.getAttribute('id'); || e.id
+ 并非所有的元素特性都能用元素属性表示
+ 使用 `data-` 作为自定义属性的前缀

4. 样式在何处
+ 样式信息位于 DOM 元素中的 style 属性上
+ 元素 style 属性中的任何值，都优先于样式表继承的值(即使使用 !important 的注释)

5. 样式属性命名
+ `font-weight` 会转换成 `fontWeight`

6. 获取计算后样式
+ getComputedStyle 方法可以获取指定元素上的所有样式
+ 获取属性时只能获取单个属性而不能获取混合属性 border-bottom-radius

7. 测量元素的高度和宽度  
+ height 和 weight 在不指定值的情况下默认值是 auto，所以不能通过其获得准确的值
+ offsetHeight 和 offsetWidth 可以访问实际元素的高度和宽度，但是他们都包括 padding
+ 元素如果不显示的话就没有尺寸
+ 获取隐藏元素在非隐藏状态下的尺寸:
display:block  - 获取真实值  
visibility:hidden  - 不可见，但会显示为一片空白  
position:absolute  - 移除正常的可视区							
获取元素尺寸  
恢复属性  

8. 避免布局抖动
+ 对 DOM 进行一系列连贯的读写操作后会发生布局抖动，此过程中浏览器无法执行布局优化
+ 问题在于，浏览器必须在读取布局信息之前先重新计算布局，性能消耗大
+ 使用不会导致浏览器重排的方式编写代码
+ 批量读取/写入
+ react 的虚拟 DOM 

## chapter 13 历久弥新的事件

### questions
1. 为什么不能保证定时器回调的时机
2. 如果 setInterval 定时器每 3ms 执行一次，而事件处理程序需要运行 16ms，那么定时器的回调函数将被添加到微任务队列中多少次
3. 为什么事件处理程序的函数上下文有时与事件的目标不同

### notes
1. 事件循环
+ 宏任务和微任务
+ 宏任务代表一个个离散的，独立工作单元。运行完任务后，浏览器可以继续其他调度
+ 微任务是更小的任务。必须在浏览器继续执行其他任务之前更新引用程序的状态。浏览器任务包括重新渲染页面的 UI。
+ 微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。
+ 微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘会使应用程序的状态不连续。
+ 事件循环的实现至少应该含有一个用于宏任务的队列和至少一个用于微任务的队列
+ 事件循环基于两个基本原则:
一次处理一个任务  
一个任务开始后直到运行完成，不会被其他任务中断  
+ 宏任务和微任务队列之间的区别:   
单次循环迭代中，最多处理一个宏任务，而队列中的所有微任务都会被处理  
+ 微任务队列处理完成并清空后，时间循环会检查是否需要更新 UI 渲染
+ 处理鼠标移动会导致大量的事件进入队列，
+ 浏览器大概每秒渲染60次 

2. 仅含宏任务的示例
+ 事件监听和添加任务是独立于事件循环的  
+ 主线程 js 代码运行结束，完成执行了一个任务时，事件循环会检查微任务队列

3. 同时含有宏任务和微任务的示例
+ 微任务会尽可能快地执行但不会中断当前任务  
+ 每当执行一个任务时，事件循环总是首先检查微任务队列，目的是在处理其他任务前把所有微任务执行完
+ 在宏任务开始执行后，事件循环立即执行微任务，而不需要等待页面渲染
+ 当且仅当两个宏任务之间没有微任务时可以渲染页面

4. 计时器:延迟执行和间隔执行
+ 宿主环境(浏览器或 Node.js )提供了创建/清除计时器的方法   
setInterval() setTimeout() clearInterval() clearTimeout()  
+ 无法确保计时器延迟的时间  

5. 在事件循环中执行计时器
+ 一个任务一旦开始执行就无法被其他任务中断
+ 如果 interval 事件触发，并且队列中已经有对应的任务等待执行时，不会再添加新任务
+ 因为 js 是单线程，只能控制计时器何时被加入队列中，而不能控制何时执行

6. 处理计算复杂度高的任务
+ 使用一个计时器来中断一个长时间运行的任务
+ 使用计时器将长时间运行的任务分解成不会堵塞事件循环的小任务，页面可以重新渲染

7. 通过 DOM 代理事件
+ Netscape 事件模型:事件处理器的执行顺序:document outer inner 事件捕获
+ Microsoft 事件模型:事件处理器的执行顺序:inner outer document 事件冒泡
+ W3C 标准更倾向于事件冒泡  
+ 事件处理器中的 this 关键字，指向的是事件处理器注册的元素，不一定是发生事件的元素。event.target 指向事件发生的元素
+ addEventListener() 第三个元素 true为捕获模式 false为冒泡模式

8. 自定义事件
+ 紧耦合:共享代码为函数，需要固定名称，处理多件事会发送多条通知  
+ 松耦合:代码触发匹配条件时，不用指定关于代码的细节。可以创建任意数量的事件处理器。并且事件处理器之间是完全独立的。

## chapter 14 跨浏览器开发技巧

### questions
1. 处理不同浏览器行为不一致的常见方法是什么
2. 你的代码在别人页面上可用的最佳方式是什么
3. 为什么在跨浏览器编写脚本时垫片非常有用

### notes
1. 代码封装
2. 模范代码
3. 应对 ID 滥用
+ 避免 id  冲突
4. 外部样式加载放在脚本之前
5. 回归:过去使用的特性不再运行了
6. 特性检测->不含有内置函数则使用垫片(自定义)

## ES6 附加特性
1. 模板字符串 
```
`${}`
```
2. 解构
```js
const {xxx,xx,xx} = ninja;
```
3. 使用对象字面量创建对象